install.packages("renv")
library(renv)
renv::activate()
renv::snapshot()
Sys.time()
a <- Sys.time()
b <- Sys.time()
a-b
as.numeric(a-b)
a-b
(a-b)*2
as.numeric(difftime(a, b, units = "secs"))
data <- data.frame(
col1 = sample(1:100, 100, replace = TRUE),
col2 = sample(1:100, 100, replace = TRUE),
col3 = rnorm(100),
col4 = rnorm(100),
col5 = rnorm(100)
)
data
p.miss <- 0.2
M <- matrix(rbinom(100*5, 1, p.miss), 100, 5)
data[M == 1] <- NA
# impute the data
targets::tar_source()
# impute the data
targets::tar_source()
library(targets)
data <- read.csv("data/ExpA/simulation_set_up.csv")
head(data)
data[["method"]]
data
head(data)
data <- data[[c("method", "n_train", "rep" , "prop1", "corr", "prcNA", metric)]]
metric <- "angular_error"
data <- data[[c("method", "n_train", "rep" , "prop1", "corr", "prcNA", metric)]]
data <- data[[c("method", "n_train", "rep" , "prop1", "corr", "prcNA", metric)]]
data <- data[c("method", "n_train", "rep" , "prop1", "corr", "prcNA", metric)]
data
xtabs(~ corr + prop1, data = data)
plot.design(metric ~ ., data = data)
plot.design(str(metric) ~ ., data = data)
plot.design(angular_error ~ ., data = data)
# factorize
data$method <- factor(data$method)
xtabs(~ corr + prop1, data = data)
plot.design(angular_error ~ ., data = data)
library(dplyr)
data <- read.csv("data/ExpA/simulation_set_up.csv")
metric <- "angular_error"
data <- data[c("method", "n_train", "rep" , "prop1", "corr", "prcNA", metric)]
methods_used <- c("SAEM", "Mean.IMP", "MICE.IMP", "05.IMP", "Mean.IMP.M")
data <- data[data$method %in% methods_used,]
# factorize
data$method <- factor(data$method)
xtabs(~ corr + prop1, data = data)
plot.design(angular_error ~ ., data = data)
# factorize
data$method <- factor(data$method)
data$corr <- factor(data$corr)
data$n_train <- factor(data$n_train)
data$rep <- factor(data$rep)
data$prcNA <- factor(data$prcNA)
data$prop1 <- factor(data$prop1)
xtabs(~ corr + prop1, data = data)
plot.design(angular_error ~ ., data = data)
stripchart(y ~ interaction(exposure, location), data = data, pch = 1,
vertical = TRUE,
method = "jitter") ## jitter because of replicates
stripchart(angular_error ~ interaction(method, n_train), data = data, pch = 1,
vertical = TRUE,
method = "jitter") ## jitter because of replicates
stripchart(angular_error ~ interaction(corr, prcNA, prop1), data = data, pch = 1,
vertical = TRUE,
method = "jitter") ## jitter because of replicates
interaction.plot(x.factor = data$corr,
trace.factor = data$prop1,
response = data$angular_error)
interaction.plot(x.factor = data$corr,
trace.factor = data$method,
response = data$angular_error)
interaction.plot(x.factor = data$n_train,
trace.factor = data$method,
response = data$angular_error)
fit <- aov(angular_error ~ corr + prop1 + n_train + method + prcNA, data = data)
summary(fit)
coef(fit)
dummy.coef(fit)
dummy.coef(fit)
fit <- aov(angular_error ~ corr * prop1 * n_train * method * prcNA, data = data)
summary(fit)
summary(fit)
coef(fit)
dummy.coef(fit)
total_SS <- sum((data$angular_error - mean(data$angular_error))^2)
# corr
(corr_SS <- sum((tapply(data$angular_error, data$corr, mean) - mean(data$angular_error))^2))
(total_SS <- sum((data$angular_error - mean(data$angular_error))^2))
# corr
(corr_SS <- sum((tapply(data$angular_error, data$corr, mean) - mean(data$angular_error))^2))
# method
(method_SS <- sum((tapply(data$angular_error, data$method, mean) - mean(data$angular_error))^2))
# n_train
(n_train_SS <- sum((tapply(data$angular_error, data$n_train, mean) - mean(data$angular_error))^2))
# prcNA
(prcNA_SS <- sum((tapply(data$angular_error, data$prcNA, mean) - mean(data$angular_error))^2))
# interaction
(interaction_SS <- sum((tapply(data$angular_error, interaction(data$corr, data$prcNA), mean) - mean(data$angular_error))^2))
par(mfrow = c(1, 2))
plot(fit, which = 1)
plot(fit, which = 2)
data$angular_error <- log(1 + data$angular_error)
# factorize
data$method <- factor(data$method)
data$corr <- factor(data$corr)
data$n_train <- factor(data$n_train)
data$rep <- factor(data$rep)
data$prcNA <- factor(data$prcNA)
data$prop1 <- factor(data$prop1)
xtabs(~ corr + prop1, data = data)
plot.design(angular_error ~ ., data = data)
stripchart(angular_error ~ interaction(corr, prcNA, prop1), data = data, pch = 1,
vertical = TRUE,
method = "jitter") ## jitter because of replicates
interaction.plot(x.factor = data$n_train,
trace.factor = data$method,
response = data$angular_error)
options(contrasts = c("contr.sum", "contr.poly"))
fit <- aov(angular_error ~ corr * prop1 * n_train * method * prcNA, data = data)
summary(fit)
coef(fit)
dummy.coef(fit)
par(mfrow = c(1, 2))
plot(fit, which = 1)
plot(fit, which = 2)
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(effectsize)  # for variance decomposition
library(tidyr)
install.packages("ggplot2")
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
install.packages("gridExtra")
library(gridExtra)
library(effectsize)  # for variance decomposition
install.packages("effectsize")
library(tidyr)
# Read and prepare data
data <- read.csv("data/ExpA/simulation_set_up.csv")
metric <- "angular_error"
data <- data[c("method", "n_train", "rep", "prop1", "corr", "prcNA", metric)]
methods_used <- c("SAEM", "Mean.IMP", "MICE.IMP", "05.IMP", "Mean.IMP.M")
data <- data[data$method %in% methods_used,]
# Convert to factors
data <- data %>%
mutate(across(c(method, corr, n_train, rep, prcNA, prop1), factor))
# 1. Enhanced visualization of distributions
plot_distributions <- function(data) {
ggplot(data, aes(x = angular_error, fill = method)) +
geom_density(alpha = 0.5) +
facet_grid(corr ~ prcNA) +
theme_minimal() +
labs(title = "Distribution of Angular Error by Method",
subtitle = "Faceted by Correlation and Missing Data Percentage",
x = "Angular Error",
y = "Density") +
theme(legend.position = "bottom")
}
# 2. Box plots with interaction
plot_interactions <- function(data) {
ggplot(data, aes(x = interaction(corr, prcNA), y = angular_error, fill = method)) +
geom_boxplot() +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "Angular Error by Method and Conditions",
x = "Correlation x Missing Data %",
y = "Angular Error")
}
# 3. Heat map of mean angular errors
plot_heatmap <- function(data) {
data %>%
group_by(method, corr, prcNA) %>%
summarize(mean_error = mean(angular_error), .groups = 'drop') %>%
ggplot(aes(x = corr, y = prcNA, fill = mean_error)) +
geom_tile() +
facet_wrap(~method) +
scale_fill_viridis_c() +
theme_minimal() +
labs(title = "Mean Angular Error Across Conditions",
fill = "Mean Error")
}
# 4. Variance decomposition visualization
variance_decomposition <- function(fit) {
# Calculate eta squared for all terms
eta <- eta_squared(fit, partial = FALSE)
# Create plot
ggplot(data.frame(term = eta$Term,
eta_sq = eta$Eta2),
aes(x = reorder(term, eta_sq), y = eta_sq)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_minimal() +
labs(title = "Variance Decomposition",
x = "Model Terms",
y = "Eta Squared")
}
# 5. Diagnostic plots using ggplot2
diagnostic_plots <- function(fit) {
# Residuals vs Fitted
p1 <- ggplot(data.frame(fitted = fitted(fit),
residuals = resid(fit)),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
theme_minimal() +
labs(title = "Residuals vs Fitted")
# Normal Q-Q
p2 <- ggplot(data.frame(theoretical = qnorm(ppoints(length(resid(fit)))),
sample = sort(scale(resid(fit)))),
aes(x = theoretical, y = sample)) +
geom_point() +
geom_abline() +
theme_minimal() +
labs(title = "Normal Q-Q Plot")
grid.arrange(p1, p2, ncol = 2)
}
# Fit model
options(contrasts = c("contr.sum", "contr.poly"))
fit <- aov(angular_error ~ corr * prop1 * n_train * method * prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
# Display plots
print(p1)
print(p2)
print(p3)
print(p4)
p4 <- variance_decomposition(fit)
library(effectsize)
library(tidyr)
# Read and prepare data
data <- read.csv("data/ExpA/simulation_set_up.csv")
metric <- "angular_error"
data <- data[c("method", "n_train", "rep", "prop1", "corr", "prcNA", metric)]
methods_used <- c("SAEM", "Mean.IMP", "MICE.IMP", "05.IMP", "Mean.IMP.M")
data <- data[data$method %in% methods_used,]
# Convert to factors
data <- data %>%
mutate(across(c(method, corr, n_train, rep, prcNA, prop1), factor))
# 1. Enhanced visualization of distributions
plot_distributions <- function(data) {
ggplot(data, aes(x = angular_error, fill = method)) +
geom_density(alpha = 0.5) +
facet_grid(corr ~ prcNA) +
theme_minimal() +
labs(title = "Distribution of Angular Error by Method",
subtitle = "Faceted by Correlation and Missing Data Percentage",
x = "Angular Error",
y = "Density") +
theme(legend.position = "bottom")
}
# 2. Box plots with interaction
plot_interactions <- function(data) {
ggplot(data, aes(x = interaction(corr, prcNA), y = angular_error, fill = method)) +
geom_boxplot() +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "Angular Error by Method and Conditions",
x = "Correlation x Missing Data %",
y = "Angular Error")
}
# 3. Heat map of mean angular errors
plot_heatmap <- function(data) {
data %>%
group_by(method, corr, prcNA) %>%
summarize(mean_error = mean(angular_error), .groups = 'drop') %>%
ggplot(aes(x = corr, y = prcNA, fill = mean_error)) +
geom_tile() +
facet_wrap(~method) +
scale_fill_viridis_c() +
theme_minimal() +
labs(title = "Mean Angular Error Across Conditions",
fill = "Mean Error")
}
# 4. Variance decomposition visualization
variance_decomposition <- function(fit) {
# Calculate eta squared for all terms
eta <- eta_squared(fit, partial = FALSE)
# Create plot
ggplot(data.frame(term = eta$Term,
eta_sq = eta$Eta2),
aes(x = reorder(term, eta_sq), y = eta_sq)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_minimal() +
labs(title = "Variance Decomposition",
x = "Model Terms",
y = "Eta Squared")
}
# 5. Diagnostic plots using ggplot2
diagnostic_plots <- function(fit) {
# Residuals vs Fitted
p1 <- ggplot(data.frame(fitted = fitted(fit),
residuals = resid(fit)),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
theme_minimal() +
labs(title = "Residuals vs Fitted")
# Normal Q-Q
p2 <- ggplot(data.frame(theoretical = qnorm(ppoints(length(resid(fit)))),
sample = sort(scale(resid(fit)))),
aes(x = theoretical, y = sample)) +
geom_point() +
geom_abline() +
theme_minimal() +
labs(title = "Normal Q-Q Plot")
grid.arrange(p1, p2, ncol = 2)
}
# Fit model
options(contrasts = c("contr.sum", "contr.poly"))
fit <- aov(angular_error ~ corr * prop1 * n_train * method * prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
fit <- aov(angular_error ~ corr + prop1 + n_train + method + prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
# 4. Variance decomposition visualization
variance_decomposition <- function(fit) {
# Calculate eta squared for all terms
eta <- eta_squared(fit, partial = FALSE)
print(eta)
# Create plot
ggplot(data.frame(term = eta$Term,
eta_sq = eta$Eta2),
aes(x = reorder(term, eta_sq), y = eta_sq)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_minimal() +
labs(title = "Variance Decomposition",
x = "Model Terms",
y = "Eta Squared")
}
# 5. Diagnostic plots using ggplot2
diagnostic_plots <- function(fit) {
# Residuals vs Fitted
p1 <- ggplot(data.frame(fitted = fitted(fit),
residuals = resid(fit)),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
theme_minimal() +
labs(title = "Residuals vs Fitted")
# Normal Q-Q
p2 <- ggplot(data.frame(theoretical = qnorm(ppoints(length(resid(fit)))),
sample = sort(scale(resid(fit)))),
aes(x = theoretical, y = sample)) +
geom_point() +
geom_abline() +
theme_minimal() +
labs(title = "Normal Q-Q Plot")
grid.arrange(p1, p2, ncol = 2)
}
# Fit model
options(contrasts = c("contr.sum", "contr.poly"))
fit <- aov(angular_error ~ corr + prop1 + n_train + method + prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
eta
eta_squared(fit, partial = FALSE)
eta
eta eta_squared(fit, partial = FALSE)
eta <- eta_squared(fit, partial = FALSE)
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(effectsize)
library(tidyr)
# Read and prepare data
data <- read.csv("data/ExpA/simulation_set_up.csv")
metric <- "angular_error"
data <- data[c("method", "n_train", "rep", "prop1", "corr", "prcNA", metric)]
methods_used <- c("SAEM", "Mean.IMP", "MICE.IMP", "05.IMP", "Mean.IMP.M")
data <- data[data$method %in% methods_used,]
# Convert to factors
data <- data %>%
mutate(across(c(method, corr, n_train, rep, prcNA, prop1), factor))
# 1. Enhanced visualization of distributions
plot_distributions <- function(data) {
ggplot(data, aes(x = angular_error, fill = method)) +
geom_density(alpha = 0.5) +
facet_grid(corr ~ prcNA) +
theme_minimal() +
labs(title = "Distribution of Angular Error by Method",
subtitle = "Faceted by Correlation and Missing Data Percentage",
x = "Angular Error",
y = "Density") +
theme(legend.position = "bottom")
}
# 2. Box plots with interaction
plot_interactions <- function(data) {
ggplot(data, aes(x = interaction(corr, prcNA), y = angular_error, fill = method)) +
geom_boxplot() +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "Angular Error by Method and Conditions",
x = "Correlation x Missing Data %",
y = "Angular Error")
}
# 3. Heat map of mean angular errors
plot_heatmap <- function(data) {
data %>%
group_by(method, corr, prcNA) %>%
summarize(mean_error = mean(angular_error), .groups = 'drop') %>%
ggplot(aes(x = corr, y = prcNA, fill = mean_error)) +
geom_tile() +
facet_wrap(~method) +
scale_fill_viridis_c() +
theme_minimal() +
labs(title = "Mean Angular Error Across Conditions",
fill = "Mean Error")
}
# 4. Variance decomposition visualization
variance_decomposition <- function(fit) {
# Calculate eta squared for all terms
eta <- eta_squared(fit, partial = FALSE)
print(eta)
# Create plot
ggplot(data.frame(term = eta$Parameter,
eta_sq = eta$Eta2),
aes(x = reorder(term, eta_sq), y = eta_sq)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_minimal() +
labs(title = "Variance Decomposition",
x = "Model Terms",
y = "Eta Squared")
}
# 5. Diagnostic plots using ggplot2
diagnostic_plots <- function(fit) {
# Residuals vs Fitted
p1 <- ggplot(data.frame(fitted = fitted(fit),
residuals = resid(fit)),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
theme_minimal() +
labs(title = "Residuals vs Fitted")
# Normal Q-Q
p2 <- ggplot(data.frame(theoretical = qnorm(ppoints(length(resid(fit)))),
sample = sort(scale(resid(fit)))),
aes(x = theoretical, y = sample)) +
geom_point() +
geom_abline() +
theme_minimal() +
labs(title = "Normal Q-Q Plot")
grid.arrange(p1, p2, ncol = 2)
}
# Fit model
options(contrasts = c("contr.sum", "contr.poly"))
fit <- aov(angular_error ~ corr + prop1 + n_train + method + prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
# Display plots
print(p1)
print(p2)
print(p3)
print(p4)
diagnostic_plots(fit)
# Summary statistics
summary(fit)
# Effect size analysis
eta_squared(fit, partial = TRUE) %>%
arrange(desc(Eta2_partial))
fit <- aov(angular_error ~ corr * prop1 * n_train * method * prcNA, data = data)
# Generate all plots
p1 <- plot_distributions(data)
p2 <- plot_interactions(data)
p3 <- plot_heatmap(data)
p4 <- variance_decomposition(fit)
# Display plots
print(p1)
print(p2)
print(p3)
print(p4)
diagnostic_plots(fit)
# Summary statistics
summary(fit)
# Effect size analysis
eta_squared(fit, partial = TRUE) %>%
arrange(desc(Eta2_partial))
?eta_squared
?eta_squared
